<svg width="140" height="30">

    <a xlink:href="https://developer.mozilla.org/en-US/docs/SVG" target="_blank">
        <rect height="30" width="120" y="0" x="0" rx="15" />
        <text fill="white" text-anchor="middle" y="21" x="60">SVG on MDN</text>
    </a>

</svg>

<svg width="50" viewBox="0 0 120 120">
    <circle cx="60" cy="60" r="50" />
</svg>

<svg width="500" height="500" viewBox="0 0 1000 300">
    <defs>
        <path id="MyPath" d="M 100 200 
             C 200 100 300   0 400 100
             C 500 200 600 300 700 200
             C 800 100 900 100 900 100" />
    </defs>
    <use xlink:href="#MyPath" fill="none" stroke="red" />
    <text font-family="Verdana" font-size="42.5">
        <textPath xlink:href="#MyPath">
            We go up, then we go down, then up again
        </textPath>
    </text>
    <!-- Show outline of the viewport using 'rect' element -->
    <rect x="1" y="1" width="998" height="298" fill="none" stroke="black" stroke-width="2" />
</svg>


<svg width="120" height="120" viewBox="0 0 120 120">
    <rect x="10" y="10" width="100" height="100" ry="15" rx="15" />
</svg>

<svg viewBox="0 0 100 100" width="200" height="200">
    <clipPath id="myClip">
        <!--
            圆圈外的所有东西都会被裁剪掉，因此不可见。
          -->
        <circle cx="40" cy="35" r="15" />
    </clipPath>

    <!-- 作为引用元素（英文原文：for reference）的黑色心形 -->
    <path id="heart" d="M10,30 A20,20,0,0,1,50,30 A20,20,0,0,1,90,30 Q90,60,50,90 Q10,60,10,30 Z" />

    <!--
          和上述黑色心形形状相同的红色心形，剪切路径是上面定义的圆；
          红色心形只有在圆内的部分可见。
        -->
    <use clip-path="url(#myClip)" xlink:href="#heart" fill="red" />
</svg>


<svg xmlns="http://www.w3.org/2000/svg" width="120" height="120" viewPort="0 0 120 120" version="1.1">
    <ellipse cx="60" cy="60" rx="50" ry="25" />

</svg>


<svg viewBox="0 0 95 50" width="120" height="120" xmlns="http://www.w3.org/2000/svg">
    <g stroke="green" fill="white" stroke-width="5">
        <circle cx="25" cy="25" r="15" />
        <circle cx="40" cy="25" r="15" />
        <circle cx="55" cy="25" r="15" />
        <circle cx="70" cy="25" r="15" />
    </g>
</svg>

<svg>
    <!-- symbol definition  NEVER draw -->
    <symbol id="sym01" viewBox="0 0 150 110">
        <circle cx="50" cy="50" r="40" stroke-width="8" stroke="red" fill="red" />
        <circle cx="90" cy="60" r="40" stroke-width="8" stroke="green" fill="white" />
    </symbol>

    <!-- actual drawing by "use" element -->
    <use xlink:href="#sym01" x="0" y="0" width="100" height="50" />
    <use xlink:href="#sym01" x="0" y="50" width="75" height="38" />
    <use xlink:href="#sym01" x="0" y="100" width="50" height="25" />
</svg>

<!-- ****************path******************** -->
<!-- 5个指令：M H V L Z -->
<!-- 贝塞尔曲线： -->
<svg width="190px" height="160px" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 10 C 10 80, 60 80, 60 10" stroke="black" fill="transparent" />
    <!-- C 三次贝塞尔曲线，需要4个点，起点就是当前位置 10,10，接下来依次是两个控制点，最后一个是终点 -->

    <!-- 创建连续的曲线，衔接处斜率不变是看起来平滑的关键，
        为了保持斜率不变，第二条曲线的第一个控制点和前一条曲线的最后一个控制点应该是对称的，
        对称中心就是第二条曲线的起点（也是第一条曲线的终点）
    创建连续曲线的简化指令S（s） -->
    <path d="M10 80 C 40 10, 65 10, 95 80 C 125 150, 150 150, 180 80" stroke="black" fill="transparent" />
    <!-- 点65 10 和125 150 是对称的，对称中心是9580，
        为了简化这个计算，可用S指令，S指令无需指明第一个控制点了（第一个控制点始终由前一条曲线决定），只需指明第二个控制点和终点
    S指令必须接在C指令或S指令后面,否则就会将当前点（起点）作为第一个控制点 -->
    <path d="M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80" stroke="black" fill="transparent" />
</svg>

<svg width="190px" height="160px" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 80 Q 95 10, 180 80" stroke="black" fill="transparent" />
    <path d="M10 80 Q 52.5 10, 95 80 T 180 80" stroke="black" fill="transparent" />
    <!-- Q创建二次贝塞尔曲线，T命令相对于Q类似于S命令相对于C -->
</svg>


<!-- 弧线： -->
<!-- A 参数比较多 xr yr rotate isLargeRadius isClockDirection dx dy -->
<svg width="325px" height="325px" version="1.1" xmlns="http://www.w3.org/2000/svg">
    <path d="M80 230
             A 45 45, 0, 0, 1, 125 275
             L 125 230 Z" fill="purple" />
</svg>

<svg width="190px" height="160px">
    <path d="M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80" stroke="black" stroke-width="1" fill="transparent" stroke-dasharray="3" />
    <!-- fill 和 stroke 都是颜色，而fill-opacity和stroke-opacity是透明度的，如果颜色写了个rgba的值，又同时设置了xxx-opacity属性，那么两个不透明度信息都会叠加起作用。-->
    <!-- stroke-width、 -->
    <!-- stroke-linecap定义线的断点形状 和 stroke-linejoin 定义两个线之间的链接处的处理-->
    <!-- stroke-dasharray 灵活定义各种虚线，一组数字被依次循环使用，实线长度，虚线长度。如 5,3,5 表示： 5实 3虚 5实 5虚 3实 5虚 5实 …… 注意第一段从实现开始 -->
</svg>
<img src="./stroke.jpg">

<svg width="160" height="140" xmlns="http://www.w3.org/2000/svg" version="1.1">
    <line x1="40" x2="120" y1="20" y2="20" stroke="black" stroke-width="20" stroke-linecap="butt"/>
    <line x1="40" x2="120" y1="60" y2="60" stroke="black" stroke-width="20" stroke-linecap="square"/>
    <line x1="40" x2="120" y1="100" y2="100" stroke="black" stroke-width="20" stroke-linecap="round"/>
</svg>