<canvas id="cvs" style="border: 1px solid #eee;" width="500" height="500">你的浏览器不支持canvas</canvas>
<script>
    const canvas = document.getElementById('cvs')
    var ctx = canvas.getContext('2d');  // 每个canvas都有2d和3d的绘制上下文，只有通过这个上下文才能进行绘制。

    /* ctx.fillStyle = 'rgb(200, 0, 0)';
    ctx.fillRect(10, 10, 50, 50);
    ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';
    ctx.fillRect(30, 30, 50, 50); */



    /* ctx.fillRect(25, 25, 100, 100);
    ctx.clearRect(45, 45, 60, 60);
    ctx.strokeRect(50, 50, 50, 50); */


    /* ctx.beginPath();
    ctx.lineTo(75, 50);  // 第一个lineTo，将默认变成moveTo
    ctx.lineTo(100, 75);
    ctx.lineTo(100, 25);
    ctx.fill(); */


    /**
     * rectangles, triangles, lines, arcs and curves,(长方形，三角形，直线，圆弧，和曲线) 和svg不同，canvas只能支持 长方形和path。
     * 三种长方形的方法都是立即绘制
     * fillRect(x, y, width, height)    fillStyle
     * strokeRect(x, y, width, height)
     * clearRect(x, y, width, height)   相当于一个方形橡皮檫，这一片区域将变得透明。有两种替代方法。
     * rect(x, y, width, height) 绘制一个长方形路径，注意这会首先自动moveTo(x,y)。这个方法仅仅是绘制一个路径，不会产生渲染，这和上面3个方法不同！
     * 
     * path 由点组成，点之间由线连接（可能是曲线，弧线，直线），线有颜色，粗细的属性。
     * path可以是close的，subpath也可以。
     * 三步走：创建path，通过绘制指令来绘制path，最后fill或者stroke来渲染path
     * beginPath()  创建path方法，接下来的指令都将直接作用于这个path，用来构建path。
     * closePath()  当前点到起点画一条直线，封闭路径。如果已经封闭了，或只有一个点，将没由任何效果。
     * stroke()
     * fill()  会自动封闭（调用closePath)，所以fill之前不用调用closePath方法。
     *
     * moveTo(x, y)
     * lineTo(x, y)
     * arc(x, y, radius, startAngle, endAngle, anticlockwise)   // 圆心坐标，半径，起止角度，是否为逆时针方向 。
     *        anticlockwise:逆时针，起点（0角度）的位置是右侧，角度始终是顺时针计算的，最后一个参数表示画path的方向！
     *        所以在画弧度之前一定要先moveTo到起点，即你需要先计算好起点坐标。
     * arcTo(x1, y1, x2, y2, radius)  依次链接 “开始点”、“控制点1”和“控制点2”这三个点所形成的夹角，绘制一段与夹角的两边相切并且半径为radius的圆弧.
     *        圆弧的起点在“开始点--控制点1”的线段上, 开始点与圆弧起点是直线连接的
     * quadraticCurveTo(cp1x, cp1y, x, y)   二次贝塞尔曲线
     * bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)    三次贝塞尔曲线
     *
     *
     */


    /* ctx.beginPath();
    ctx.arc(75, 75, 50, 0, Math.PI * 2, true); // Outer circle
    // ctx.moveTo(110, 75);
    ctx.arc(75, 75, 35, 0, Math.PI, false);  // Mouth (clockwise)
    // ctx.moveTo(65, 65);
    ctx.arc(60, 65, 5, 0, Math.PI * 2, true);  // Left eye
    // ctx.moveTo(95, 65);
    ctx.arc(90, 65, 5, 0, Math.PI * 2, true);  // Right eye
    ctx.stroke(); */


    /* ctx.beginPath()
    ctx.arc(63, 63, 60, 0, Math.PI/6, false)
    ctx.arcTo(70, 70, 40, 100, 10)
    // ctx.lineTo(70, 70)
    ctx.lineTo(40, 100)
    // ctx.arc(63, 63, 10, 0, Math.PI*2, false)
    ctx.stroke() */

    /* ctx.beginPath();
    ctx.moveTo(75, 25);
    ctx.quadraticCurveTo(25, 25, 25, 62.5);
    ctx.quadraticCurveTo(25, 100, 50, 100);
    ctx.quadraticCurveTo(50, 120, 30, 125);
    ctx.quadraticCurveTo(60, 120, 65, 100);
    ctx.quadraticCurveTo(125, 100, 125, 62.5);
    ctx.quadraticCurveTo(125, 25, 75, 25);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(175, 40);
    ctx.bezierCurveTo(175, 37, 170, 25, 150, 25);
    ctx.bezierCurveTo(120, 25, 120, 62.5, 120, 62.5);
    ctx.bezierCurveTo(120, 80, 140, 102, 175, 120);
    ctx.bezierCurveTo(210, 102, 230, 80, 230, 62.5);
    ctx.bezierCurveTo(230, 62.5, 230, 25, 200, 25);
    ctx.bezierCurveTo(185, 25, 175, 37, 175, 40);
    ctx.fill(); */



    roundedRect(ctx, 12, 12, 150, 150, 15);
    roundedRect(ctx, 19, 19, 150, 150, 9);
    roundedRect(ctx, 53, 53, 49, 33, 10);
    roundedRect(ctx, 53, 119, 49, 16, 6);
    roundedRect(ctx, 135, 53, 49, 33, 10);
    roundedRect(ctx, 135, 119, 25, 49, 10);

    ctx.beginPath();
    ctx.arc(37, 37, 13, Math.PI / 7, -Math.PI / 7, false);
    ctx.lineTo(31, 37);
    ctx.fill();

    for (var i = 0; i < 8; i++) {
        ctx.fillRect(51 + i * 16, 35, 4, 4);
    }

    for (i = 0; i < 6; i++) {
        ctx.fillRect(115, 51 + i * 16, 4, 4);
    }

    for (i = 0; i < 8; i++) {
        ctx.fillRect(51 + i * 16, 99, 4, 4);
    }

    ctx.beginPath();
    ctx.moveTo(83, 116);
    ctx.lineTo(83, 102);
    ctx.bezierCurveTo(83, 94, 89, 88, 97, 88);
    ctx.bezierCurveTo(105, 88, 111, 94, 111, 102);
    ctx.lineTo(111, 116);
    ctx.lineTo(106.333, 111.333);
    ctx.lineTo(101.666, 116);
    ctx.lineTo(97, 111.333);
    ctx.lineTo(92.333, 116);
    ctx.lineTo(87.666, 111.333);
    ctx.lineTo(83, 116);
    ctx.fill();

    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(91, 96);
    ctx.bezierCurveTo(88, 96, 87, 99, 87, 101);
    ctx.bezierCurveTo(87, 103, 88, 106, 91, 106);
    ctx.bezierCurveTo(94, 106, 95, 103, 95, 101);
    ctx.bezierCurveTo(95, 99, 94, 96, 91, 96);
    ctx.moveTo(103, 96);
    ctx.bezierCurveTo(100, 96, 99, 99, 99, 101);
    ctx.bezierCurveTo(99, 103, 100, 106, 103, 106);
    ctx.bezierCurveTo(106, 106, 107, 103, 107, 101);
    ctx.bezierCurveTo(107, 99, 106, 96, 103, 96);
    ctx.fill();

    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(101, 102, 2, 0, Math.PI * 2, true);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(89, 102, 2, 0, Math.PI * 2, true);
    ctx.fill();
    function roundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x, y + radius);
        ctx.lineTo(x, y + height - radius);
        ctx.arcTo(x, y + height, x + radius, y + height, radius);
        ctx.lineTo(x + width - radius, y + height);
        ctx.arcTo(x + width, y + height, x + width, y + height - radius, radius);
        ctx.lineTo(x + width, y + radius);
        ctx.arcTo(x + width, y, x + width - radius, y, radius);
        ctx.lineTo(x + radius, y);
        ctx.arcTo(x, y, x, y + radius, radius);
        ctx.stroke();
    }
</script>